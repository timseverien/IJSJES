---
layout: '@layouts/Post.astro'
title: 'Design patterns: Singleton'
pubDate: 2022-08-23
draft: true
---

import { CodeFileGroup, CodeFile } from '@components/Code';

Design patterns are programming patterns we can use to solve common problems in our code. In 1994, the book “Design Patterns: Elements of Reusable Object-Oriented Software” was published and laid the foundation of many patterns we use today.

As the title reveals, however, the book describes patterns for object-oriented software. A paradigm that, for better or worse, isn’t the dominant one in JavaSscript. That doesn’t mean the design patterns can’t be used.

This post marks the first item of the series: **Design patterns**, in which we’ll liberally interpret a design pattern and translate that to JavaScript. In this first entry, we’re going to look at the **Singleton** pattern.

## What is the Singleton pattern?

> Singleton is a creational design pattern that lets you ensure that a class has only one instance, while providing a global access point to this instance.
>
> <cite>
> 	– [refactoring.guru](https://refactoring.guru/design-patterns/singleton)
> </cite>

Using a JavaScript class, the implementation looks like this:

<CodeFile filename="ImageLoader.js">
	```js
	let imageLoaderInstance = null;

	export class ImageLoader {
		#cache = new Map();

		async loadImage(source) {
			if (this.#cache.has(source)) {
				return this.#cache.get(source);
			}

			// Load image, write to cache, and return the image
		}

		static getInstance() {
			if (imageLoaderInstance) {
				return imageLoaderInstance;
			}

			return new ImageLoader();
		}
	}
	```
</CodeFile>

<CodeFile filename="index.js">
	```js
	import { ImageLoader } from './ImageLoader.js';

	const image1 = await ImageLoader.getInstance().loadImage('/dog.jpg');
	const image2 = await ImageLoader.getInstance().loadImage('/cat.jpg');
	```
</CodeFile>

## The Singleton in JavaScript

The formal implementation be greatly reduced by leveraging a JavaScript feature: modules. When we import one module twice, it won’t run the module’s code a second time, but references it’s exports. For example:

<CodeFile filename="import-this.js">
	```js
	console.log('Hello world!');

	export const value = Math.random();
	```
</CodeFile>

<CodeFile filename="index.js">
	```js
import { value as v1 } from './import-this.js';
import { value as v2 } from './import-this.js';

const { value: v3 } = await import('./import-this.js');
const { value: v4 } = await import('./import-this.js');
	```
</CodeFile>

The above code will print "Hello world!" in the console _once_ and the variables `v1`, `v2`, `v3` and `v4` will all have the same value even though the module’s export contains a random value. This proves that a JavaScript module is a Singleton by design!

Let’s rewrite the example from before as a JavaScript module.

<CodeFile filename="image.js">
	```js
	const cache = new Map();

	export async function loadImage(source) {
		if (cache.has(source)) {
			return cache.get(source);
		}

		// Load image, write to cache, and return the image
	}
	```
</CodeFile>

<CodeFile filename="index.js">
	```js
	import { loadImage } from './image.js';

	const image1 = await loadImage('/dog.jpg');
	const image2 = await loadImage('/cat.jpg');
	```
</CodeFile>

The above code is functionally identical to what we wrote before, but without classes and code to define the Singleton’s behaviour — it’s built-in!

## Conclusion

With no additional code at all, we’re able to mimic the behaviour of a Singleton by leveraging modules. This approach allows us to apply the design pattern while being consistent with other paradigms, like (impure) functional programming.
